import { render, screen, waitFor }
from '@testing-library/react' 

import userEvent from '@testing-library/user-event' 

import { CommentSection }
from '../CommentSection' 

import { AuthContext }
from '@/contexts/AuthContext' 

import { ReactNode }
from 'react' // Mock fetch global.fetch = jest.fn() const mockUser = { id: 'user-1', name: 'Test User', email: 'test@example.com', avatar: '/test-avatar.jpg', bio: 'Test bio', github: 'testuser', twitter: 'testuser', website: 'https://test.com', createdAt: new Date('2024-01-01'), updatedAt: new Date('2024-01-01'), }
const mockComments = [ { id: 'comment-1', content: 'First comment', postId: 'post-1', userId: 'user-1', createdAt: new Date('2024-01-01T10:00:00'), updatedAt: new Date('2024-01-01T10:00:00'), user: mockUser, }, { id: 'comment-2', content: 'Second comment with **markdown**', postId: 'post-1', userId: 'user-2', createdAt: new Date('2024-01-01T11:00:00'), updatedAt: new Date('2024-01-01T11:00:00'), user: { ...mockUser, id: 'user-2', name: 'Another User', email: 'another@example.com', }, }, ]
function AuthWrapper({ children, user = null }: { children: ReactNode; user?: typeof mockUser | null }) { return ( <AuthContext.Provider value={{ user, isLoading: false, signIn: jest.fn(), signOut: jest.fn() }
}> {children} </AuthContext.Provider> ) }

describe('CommentSection', () => { beforeEach(() => { jest.clearAllMocks() })
it('loads and displays comments', async () => { (fetch as jest.Mock).mockResolvedValueOnce({ ok: true, json: async () => ({ comments: mockComments }), }) render( <AuthWrapper>
<CommentSection postId="post-1" /> </AuthWrapper> ) // Initially shows loading expect(screen.getByRole('status')).toBeInTheDocument() // Wait for comments to load await waitFor(() => { expect(screen.getByText('First comment')).toBeInTheDocument() }) expect(screen.getByText('Second comment with')).toBeInTheDocument() expect(screen.getByText('markdown')).toBeInTheDocument() // Check comment count expect(screen.getByText('评论 (2)')).toBeInTheDocument() // Verify API call expect(fetch).toHaveBeenCalledWith('/api/posts/post-1/comments') })
it('shows empty state when no comments', async () => { (fetch as jest.Mock).mockResolvedValueOnce({ ok: true, json: async () => ({ comments: []
}), }) render( <AuthWrapper>
<CommentSection postId="post-1" /> </AuthWrapper> ) await waitFor(() => { expect(screen.getByText('暂无评论')).toBeInTheDocument() }) expect(screen.getByText('成为第一个评论的人吧！')).toBeInTheDocument() })
it('shows comment form when authenticated', async () => { (fetch as jest.Mock).mockResolvedValueOnce({ ok: true, json: async () => ({ comments: []
}), }) render( <AuthWrapper user={mockUser}>
<CommentSection postId="post-1" /> </AuthWrapper> ) await waitFor(() => { expect(screen.getByPlaceholderText('写下你的评论...')).toBeInTheDocument() }) expect(screen.getByRole('button', { name: '发表评论' })).toBeInTheDocument() })
it('shows sign in prompt when not authenticated', async () => { (fetch as jest.Mock).mockResolvedValueOnce({ ok: true, json: async () => ({ comments: []
}), }) render( <AuthWrapper>
<CommentSection postId="post-1" /> </AuthWrapper> ) await waitFor(() => { expect(screen.getByText('登录后即可发表评论')).toBeInTheDocument() }) expect(screen.getByRole('button', { name: '登录' })).toBeInTheDocument() })
it('submits new comment successfully', async () => { const newComment = { id: 'comment-3', content: 'New comment', postId: 'post-1', userId: 'user-1', createdAt: new Date('2024-01-01T12:00:00'), updatedAt: new Date('2024-01-01T12:00:00'), user: mockUser, } (fetch as jest.Mock) .mockResolvedValueOnce({ ok: true, json: async () => ({ comments: []
}), }) .mockResolvedValueOnce({ ok: true, json: async () => ({ comment: newComment }), }) const user = userEvent.setup() render( <AuthWrapper user={mockUser}>
<CommentSection postId="post-1" /> </AuthWrapper> ) await waitFor(() => { expect(screen.getByPlaceholderText('写下你的评论...')).toBeInTheDocument() }) // Type comment const textarea = screen.getByPlaceholderText('写下你的评论...') await user.type(textarea, 'New comment') // Submit const submitButton = screen.getByRole('button', { name: '发表评论' }) await user.click(submitButton) // Verify API call expect(fetch).toHaveBeenCalledWith('/api/posts/post-1/comments', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ content: 'New comment' }), }) // New comment should appear await waitFor(() => { expect(screen.getByText('New comment')).toBeInTheDocument() }) // Form should be cleared expect(textarea).toHaveValue('') })
it('handles comment submission error', async () => { (fetch as jest.Mock) .mockResolvedValueOnce({ ok: true, json: async () => ({ comments: []
}), }) .mockResolvedValueOnce({ ok: false, json: async () => ({ error: 'Failed to post comment' }), }) const consoleSpy = jest.spyOn(console, 'error').mockImplementation() const user = userEvent.setup() render( <AuthWrapper user={mockUser}>
<CommentSection postId="post-1" /> </AuthWrapper> ) await waitFor(() => { expect(screen.getByPlaceholderText('写下你的评论...')).toBeInTheDocument() }) // Type and submit comment const textarea = screen.getByPlaceholderText('写下你的评论...') await user.type(textarea, 'New comment') await user.click(screen.getByRole('button', { name: '发表评论' })) // Error should be logged await waitFor(() => { expect(consoleSpy).toHaveBeenCalledWith('Failed to post comment:', expect.any(Error)) }) // Form should not be cleared on error expect(textarea).toHaveValue('New comment') consoleSpy.mockRestore() })
it('handles comment deletion', async () => { (fetch as jest.Mock) .mockResolvedValueOnce({ ok: true, json: async () => ({ comments: mockComments }), }) .mockResolvedValueOnce({ ok: true, json: async () => ({ success: true }), }) const user = userEvent.setup() render( <AuthWrapper user={mockUser}>
<CommentSection postId="post-1" /> </AuthWrapper> ) await waitFor(() => { expect(screen.getByText('First comment')).toBeInTheDocument() }) // Find delete button for user's own comment const deleteButtons = screen.getAllByRole('button', { name: '删除' }) expect(deleteButtons).toHaveLength(1) // Only one comment is by the current user // Click delete await user.click(deleteButtons[0]) // Confirm deletion const confirmButton = screen.getByRole('button', { name: '确认删除' }) await user.click(confirmButton) // Verify API call expect(fetch).toHaveBeenCalledWith('/api/comments/comment-1', { method: 'DELETE', }) // Comment should be removed await waitFor(() => { expect(screen.queryByText('First comment')).not.toBeInTheDocument() }) })
it('loads more comments when scrolling', async () => { const manyComments = Array.from({ length: 15 }, (_, i) => ({ id: `comment-${i}`, content: `Comment ${i}`, postId: 'post-1', userId: 'user-1', createdAt: new Date(`2024-01-01T${10 + i}:00:00`), updatedAt: new Date(`2024-01-01T${10 + i}:00:00`), user: mockUser, })) (fetch as jest.Mock) .mockResolvedValueOnce({ ok: true, json: async () => ({ comments: manyComments.slice(0, 10), hasMore: true, }), }) .mockResolvedValueOnce({ ok: true, json: async () => ({ comments: manyComments.slice(10, 15), hasMore: false, }), }) render( <AuthWrapper>
<CommentSection postId="post-1" /> </AuthWrapper> ) // Wait for initial comments await waitFor(() => { expect(screen.getByText('Comment 0')).toBeInTheDocument() }) // Should show "Load more" button const loadMoreButton = screen.getByRole('button', { name: '加载更多' }) expect(loadMoreButton).toBeInTheDocument() // Click to load more const user = userEvent.setup() await user.click(loadMoreButton) // Verify API call with offset expect(fetch).toHaveBeenCalledWith('/api/posts/post-1/comments?offset=10') // Additional comments should appear await waitFor(() => { expect(screen.getByText('Comment 10')).toBeInTheDocument() }) // Load more button should be hidden when no more comments expect(screen.queryByRole('button', { name: '加载更多' })).not.toBeInTheDocument() })
it('toggles comment form visibility', async () => { (fetch as jest.Mock).mockResolvedValueOnce({ ok: true, json: async () => ({ comments: mockComments }), }) const user = userEvent.setup() render( <AuthWrapper user={mockUser}>
<CommentSection postId="post-1" /> </AuthWrapper> ) await waitFor(() => { expect(screen.getByText('评论 (2)')).toBeInTheDocument() }) // Form should be visible initially expect(screen.getByPlaceholderText('写下你的评论...')).toBeInTheDocument() // Click to hide const toggleButton = screen.getByRole('button', { name: '隐藏评论表单' }) await user.click(toggleButton) // Form should be hidden expect(screen.queryByPlaceholderText('写下你的评论...')).not.toBeInTheDocument() // Click to show again const showButton = screen.getByRole('button', { name: '显示评论表单' }) await user.click(showButton) // Form should be visible again expect(screen.getByPlaceholderText('写下你的评论...')).toBeInTheDocument() }) })