'use client' import { useEffect, useRef }
from 'react' 

import { useTheme }
from '@/lib/hooks/useTheme' interface DataPoint { x: string | number | Date y: number label?: string }
interface LineChartProps { data: DataPoint[]
title?: string xLabel?: string yLabel?: string height?: number showGrid?: boolean showDots?: boolean animate?: boolean color?: string formatX?: (value: any) => string formatY?: (value: number) => string className?: string }
export function LineChart({ data, title, xLabel, yLabel, height = 300, showGrid = true, showDots = true, animate = true, color = '#3B82F6', formatX = (v) => String(v), formatY = (v) => v.toLocaleString(), className = '' }: LineChartProps) { const canvasRef = useRef<HTMLCanvasElement>(null) const { theme } = useTheme() useEffect(() => { const canvas = canvasRef.current if (!canvas) return const ctx = canvas.getContext('2d') if (!ctx) return // Set canvas size const rect = canvas.getBoundingClientRect() canvas.width = rect.width * window.devicePixelRatio canvas.height = rect.height * window.devicePixelRatio ctx.scale(window.devicePixelRatio, window.devicePixelRatio) // Clear canvas ctx.clearRect(0, 0, rect.width, rect.height) // Calculate dimensions const padding = { top: 40, right: 20, bottom: 60, left: 60 }
const chartWidth = rect.width - padding.left - padding.right const chartHeight = rect.height - padding.top - padding.bottom // Calculate scales const xValues = data.map((d, i) => i) const yValues = data.map(d => d.y) const minY = Math.min(...yValues) const maxY = Math.max(...yValues) const yRange = maxY - minY || 1 const yPadding = yRange * 0.1 const xScale = (i: number) => padding.left + (i / (data.length - 1)) * chartWidth const yScale = (y: number) => padding.top + chartHeight - ((y - minY + yPadding) / (yRange + 2 * yPadding)) * chartHeight // Set styles const textColor = theme === 'dark' ? '#9CA3AF' : '#6B7280' const gridColor = theme === 'dark' ? '#374151' : '#E5E7EB' const bgColor = theme === 'dark' ? '#111827' : '#FFFFFF' ctx.font = '12px sans-serif' ctx.textAlign = 'center' ctx.textBaseline = 'middle' // Draw background ctx.fillStyle = bgColor ctx.fillRect(0, 0, rect.width, rect.height) // Draw title if (title) { ctx.fillStyle = theme === 'dark' ? '#F3F4F6' : '#111827' ctx.font = 'bold 16px sans-serif' ctx.textAlign = 'center' ctx.fillText(title, rect.width / 2, 20) }
// Draw grid if (showGrid) { ctx.strokeStyle = gridColor ctx.lineWidth = 1 ctx.setLineDash([5, 5]) // Horizontal grid lines for (let i = 0; i <= 5; i++) { const y = padding.top + (i / 5) * chartHeight ctx.beginPath() ctx.moveTo(padding.left, y) ctx.lineTo(padding.left + chartWidth, y) ctx.stroke() }
// Vertical grid lines for (let i = 0; i < data.length; i += Math.ceil(data.length / 10)) { const x = xScale(i) ctx.beginPath() ctx.moveTo(x, padding.top) ctx.lineTo(x, padding.top + chartHeight) ctx.stroke() }
ctx.setLineDash([]) }
// Draw axes ctx.strokeStyle = textColor ctx.lineWidth = 2 // Y-axis ctx.beginPath() ctx.moveTo(padding.left, padding.top) ctx.lineTo(padding.left, padding.top + chartHeight) ctx.stroke() // X-axis ctx.beginPath() ctx.moveTo(padding.left, padding.top + chartHeight) ctx.lineTo(padding.left + chartWidth, padding.top + chartHeight) ctx.stroke() // Draw Y-axis labels ctx.fillStyle = textColor ctx.font = '11px sans-serif' ctx.textAlign = 'right' ctx.textBaseline = 'middle' for (let i = 0; i <= 5; i++) { const value = minY - yPadding + (i / 5) * (yRange + 2 * yPadding) const y = padding.top + chartHeight - (i / 5) * chartHeight ctx.fillText(formatY(value), padding.left - 10, y) }
// Draw Y-axis label if (yLabel) { ctx.save() ctx.translate(15, rect.height / 2) ctx.rotate(-Math.PI / 2) ctx.textAlign = 'center' ctx.fillText(yLabel, 0, 0) ctx.restore() }
// Draw X-axis labels ctx.textAlign = 'center' ctx.textBaseline = 'top' const labelInterval = Math.ceil(data.length / 10) for (let i = 0; i < data.length; i += labelInterval) { const x = xScale(i) ctx.fillText(formatX(data[i].x), x, padding.top + chartHeight + 10) }
// Draw X-axis label if (xLabel) { ctx.textAlign = 'center' ctx.fillText(xLabel, rect.width / 2, rect.height - 10) }
// Draw line if (data.length > 0) { // Create gradient const gradient = ctx.createLinearGradient(0, padding.top, 0, padding.top + chartHeight) gradient.addColorStop(0, color) gradient.addColorStop(1, color + '20') // Draw area fill ctx.fillStyle = gradient ctx.beginPath() ctx.moveTo(xScale(0), padding.top + chartHeight) data.forEach((point, i) => { ctx.lineTo(xScale(i), yScale(point.y)) }) ctx.lineTo(xScale(data.length - 1), padding.top + chartHeight) ctx.closePath() ctx.fill() // Draw line ctx.strokeStyle = color ctx.lineWidth = 2 ctx.beginPath() data.forEach((point, i) => { if (i === 0) { ctx.moveTo(xScale(i), yScale(point.y)) }
else { ctx.lineTo(xScale(i), yScale(point.y)) }
}) ctx.stroke() // Draw dots if (showDots) { ctx.fillStyle = color data.forEach((point, i) => { ctx.beginPath() ctx.arc(xScale(i), yScale(point.y), 4, 0, Math.PI * 2) ctx.fill() // Draw value label on hover (simplified) if (point.label) { ctx.save() ctx.fillStyle = bgColor ctx.strokeStyle = color ctx.lineWidth = 1 const labelWidth = ctx.measureText(point.label).width + 10 const labelX = xScale(i) const labelY = yScale(point.y) - 15 ctx.fillRect(labelX - labelWidth / 2, labelY - 10, labelWidth, 20) ctx.strokeRect(labelX - labelWidth / 2, labelY - 10, labelWidth, 20) ctx.fillStyle = textColor ctx.textAlign = 'center' ctx.textBaseline = 'middle' ctx.fillText(point.label, labelX, labelY) ctx.restore() }
}) }
}
// Draw "no data" message if empty if (data.length === 0) { ctx.fillStyle = textColor ctx.textAlign = 'center' ctx.textBaseline = 'middle' ctx.font = '14px sans-serif' ctx.fillText('暂无数据', rect.width / 2, rect.height / 2) }
}, [data, title, xLabel, yLabel, showGrid, showDots, color, formatX, formatY, theme]) return ( <div className={`relative ${className}`}>
<canvas ref={canvasRef}
className="w-full" style={{ height }
}
/> </div> ) }