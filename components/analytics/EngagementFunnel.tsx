'use client' import { useEffect, useRef }
from 'react' 

import { useTheme }
from '@/lib/hooks/useTheme' interface FunnelStage { name: string value: number color?: string }
interface EngagementFunnelProps { stages: FunnelStage[]
title?: string height?: number showPercentage?: boolean showDropoff?: boolean animate?: boolean className?: string }
export function EngagementFunnel({ stages, title, height = 400, showPercentage = true, showDropoff = true, animate = true, className = '' }: EngagementFunnelProps) { const canvasRef = useRef<HTMLCanvasElement>(null) const { theme } = useTheme() const animationRef = useRef<number>() const progressRef = useRef(0) useEffect(() => { const canvas = canvasRef.current if (!canvas || stages.length === 0) return const ctx = canvas.getContext('2d') if (!ctx) return // Set canvas size const rect = canvas.getBoundingClientRect() canvas.width = rect.width * window.devicePixelRatio canvas.height = rect.height * window.devicePixelRatio ctx.scale(window.devicePixelRatio, window.devicePixelRatio) // Animation setup const startTime = Date.now() const duration = animate ? 1000 : 0 const draw = () => { // Clear canvas ctx.clearRect(0, 0, rect.width, rect.height) // Calculate progress const elapsed = Date.now() - startTime progressRef.current = Math.min(elapsed / duration, 1) const progress = animate ? easeOutCubic(progressRef.current) : 1 // Set styles const textColor = theme === 'dark' ? '#F3F4F6' : '#111827' const bgColor = theme === 'dark' ? '#111827' : '#FFFFFF' const labelBgColor = theme === 'dark' ? '#1F2937' : '#F3F4F6' // Draw background ctx.fillStyle = bgColor ctx.fillRect(0, 0, rect.width, rect.height) // Draw title if (title) { ctx.fillStyle = textColor ctx.font = 'bold 16px sans-serif' ctx.textAlign = 'center' ctx.textBaseline = 'top' ctx.fillText(title, rect.width / 2, 20) }
// Calculate dimensions const padding = { top: title ? 60 : 40, right: 40, bottom: 40, left: 40 }
const funnelWidth = rect.width - padding.left - padding.right const funnelHeight = rect.height - padding.top - padding.bottom const stageHeight = funnelHeight / stages.length // Find max value const maxValue = Math.max(...stages.map(s => s.value)) // Default colors const defaultColors = ['#3B82F6', '#10B981', '#F59E0B', '#EF4444', '#8B5CF6', '#EC4899'] // Draw funnel stages stages.forEach((stage, index) => { const y = padding.top + index * stageHeight const stageProgress = progress // Calculate trapezoid dimensions const topWidth = index === 0 ? funnelWidth : (stages[index - 1].value / maxValue) * funnelWidth * 0.9 const bottomWidth = (stage.value / maxValue) * funnelWidth * 0.9 const currentTopWidth = topWidth * stageProgress const currentBottomWidth = bottomWidth * stageProgress // Center the trapezoid const centerX = rect.width / 2 // Draw trapezoid const color = stage.color || defaultColors[index % defaultColors.length]
ctx.fillStyle = color ctx.beginPath() ctx.moveTo(centerX - currentTopWidth / 2, y) ctx.lineTo(centerX + currentTopWidth / 2, y) ctx.lineTo(centerX + currentBottomWidth / 2, y + stageHeight - 5) ctx.lineTo(centerX - currentBottomWidth / 2, y + stageHeight - 5) ctx.closePath() ctx.fill() // Add gradient overlay const gradient = ctx.createLinearGradient(0, y, 0, y + stageHeight) gradient.addColorStop(0, 'rgba(255, 255, 255, 0.1)') gradient.addColorStop(1, 'rgba(0, 0, 0, 0.1)') ctx.fillStyle = gradient ctx.fill() // Draw stage label if (stageProgress === 1) { // Label background const labelText = stage.name const valueText = stage.value.toLocaleString() const percentageText = `${((stage.value / maxValue) * 100).toFixed(1)}%` ctx.font = '14px sans-serif' const labelWidth = Math.max( ctx.measureText(labelText).width, ctx.measureText(valueText).width ) + 40 const labelX = centerX const labelY = y + stageHeight / 2 // Draw label background ctx.fillStyle = labelBgColor ctx.globalAlpha = 0.9 ctx.fillRect( labelX - labelWidth / 2, labelY - 25, labelWidth, 50 ) ctx.globalAlpha = 1 // Draw label text ctx.fillStyle = textColor ctx.font = 'bold 14px sans-serif' ctx.textAlign = 'center' ctx.textBaseline = 'middle' ctx.fillText(labelText, labelX, labelY - 10) ctx.font = '12px sans-serif' ctx.fillText(valueText, labelX, labelY + 10) // Draw percentage on the right if (showPercentage) { ctx.fillStyle = color ctx.font = 'bold 16px sans-serif' ctx.textAlign = 'left' ctx.fillText( percentageText, centerX + currentTopWidth / 2 + 20, y + stageHeight / 2 ) }
// Draw dropoff rate if (showDropoff && index > 0) { const prevValue = stages[index - 1].value const dropoff = ((prevValue - stage.value) / prevValue * 100).toFixed(1) ctx.fillStyle = '#EF4444' ctx.font = '12px sans-serif' ctx.textAlign = 'center' ctx.textBaseline = 'bottom' ctx.fillText( `↓ ${dropoff}%`, centerX, y - 5 ) }
} }) // Draw conversion rate summary if (stages.length > 1 && progressRef.current === 1) { const overallConversion = (stages[stages.length - 1].value / stages[0].value * 100).toFixed(1) ctx.fillStyle = theme === 'dark' ? '#10B981' : '#059669' ctx.font = 'bold 18px sans-serif' ctx.textAlign = 'center' ctx.textBaseline = 'bottom' ctx.fillText( `总转化率: ${overallConversion}%`, rect.width / 2, rect.height - 10 ) }
// Continue animation if (progressRef.current < 1) { animationRef.current = requestAnimationFrame(draw) }
}
draw() return () => { if (animationRef.current) { cancelAnimationFrame(animationRef.current) }
} }, [stages, title, showPercentage, showDropoff, animate, theme]) // Easing function const easeOutCubic = (t: number): number => { return 1 - Math.pow(1 - t, 3) }
return ( <div className={`relative ${className}`}>
<canvas ref={canvasRef}
className="w-full" style={{ height }
}
/> </div> ) }