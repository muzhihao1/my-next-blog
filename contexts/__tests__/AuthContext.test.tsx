import { renderHook, act, waitFor }
from '@testing-library/react' 

import { AuthProvider, useAuth }
from '../AuthContext' 

import { ReactNode }
from 'react' // Mock fetch global.fetch = jest.fn() const mockUser = { id: 'test-user-id', name: 'Test User', email: 'test@example.com', avatar: '/test-avatar.jpg', bio: 'Test bio', github: 'testuser', twitter: 'testuser', website: 'https://test.com', createdAt: '2024-01-01T00:00:00.000Z', updatedAt: '2024-01-01T00:00:00.000Z', }
function wrapper({ children }: { children: ReactNode }) { return <AuthProvider>{children}</AuthProvider> }

describe('AuthContext', () => { beforeEach(() => { jest.clearAllMocks() // Clear localStorage window.localStorage.clear() })
it('provides initial auth state', () => { const { result } = renderHook(() => useAuth(), { wrapper }) expect(result.current.user).toBeNull() expect(result.current.isLoading).toBe(true) expect(result.current.signIn).toBeDefined() expect(result.current.signOut).toBeDefined() })
it('loads user from session on mount', async () => { (fetch as jest.Mock).mockResolvedValueOnce({ ok: true, json: async () => ({ user: mockUser }), }) const { result } = renderHook(() => useAuth(), { wrapper }) await waitFor(() => { expect(result.current.isLoading).toBe(false) }) expect(fetch).toHaveBeenCalledWith('/api/auth/session') expect(result.current.user).toEqual({ ...mockUser, createdAt: new Date(mockUser.createdAt), updatedAt: new Date(mockUser.updatedAt), }) })
it('handles session fetch error', async () => { (fetch as jest.Mock).mockRejectedValueOnce(new Error('Network error')) const { result } = renderHook(() => useAuth(), { wrapper }) await waitFor(() => { expect(result.current.isLoading).toBe(false) }) expect(result.current.user).toBeNull() })
it('signs in successfully', async () => { (fetch as jest.Mock) .mockResolvedValueOnce({ ok: true, json: async () => ({ user: null }), }) .mockResolvedValueOnce({ ok: true, json: async () => ({ user: mockUser }), }) const { result } = renderHook(() => useAuth(), { wrapper }) await waitFor(() => { expect(result.current.isLoading).toBe(false) }) await act(async () => { await result.current.signIn('github') }) expect(fetch).toHaveBeenCalledWith('/api/auth/signin', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ provider: 'github' }), }) expect(result.current.user).toEqual({ ...mockUser, createdAt: new Date(mockUser.createdAt), updatedAt: new Date(mockUser.updatedAt), }) })
it('handles sign in error', async () => { (fetch as jest.Mock) .mockResolvedValueOnce({ ok: true, json: async () => ({ user: null }), }) .mockResolvedValueOnce({ ok: false, json: async () => ({ error: 'Sign in failed' }), }) const { result } = renderHook(() => useAuth(), { wrapper }) await waitFor(() => { expect(result.current.isLoading).toBe(false) }) await expect(async () => { await act(async () => { await result.current.signIn('github') }) }).rejects.toThrow('Sign in failed') expect(result.current.user).toBeNull() })
it('signs out successfully', async () => { (fetch as jest.Mock) .mockResolvedValueOnce({ ok: true, json: async () => ({ user: mockUser }), }) .mockResolvedValueOnce({ ok: true, json: async () => ({ success: true }), }) const { result } = renderHook(() => useAuth(), { wrapper }) await waitFor(() => { expect(result.current.isLoading).toBe(false) }) expect(result.current.user).not.toBeNull() await act(async () => { await result.current.signOut() }) expect(fetch).toHaveBeenCalledWith('/api/auth/signout', { method: 'POST', }) expect(result.current.user).toBeNull() })
it('handles sign out error', async () => { (fetch as jest.Mock) .mockResolvedValueOnce({ ok: true, json: async () => ({ user: mockUser }), }) .mockResolvedValueOnce({ ok: false, json: async () => ({ error: 'Sign out failed' }), }) const consoleSpy = jest.spyOn(console, 'error').mockImplementation() const { result } = renderHook(() => useAuth(), { wrapper }) await waitFor(() => { expect(result.current.isLoading).toBe(false) }) await act(async () => { await result.current.signOut() }) expect(consoleSpy).toHaveBeenCalledWith('Sign out error:', expect.any(Error)) expect(result.current.user).toBeNull() // Still clears user on error consoleSpy.mockRestore() })
it('stores auth token in localStorage on sign in', async () => { const mockToken = 'test-auth-token' (fetch as jest.Mock) .mockResolvedValueOnce({ ok: true, json: async () => ({ user: null }), }) .mockResolvedValueOnce({ ok: true, json: async () => ({ user: mockUser, token: mockToken }), }) const { result } = renderHook(() => useAuth(), { wrapper }) await waitFor(() => { expect(result.current.isLoading).toBe(false) }) await act(async () => { await result.current.signIn('github') }) expect(window.localStorage.getItem('auth-token')).toBe(mockToken) })
it('clears auth token from localStorage on sign out', async () => { window.localStorage.setItem('auth-token', 'test-token') (fetch as jest.Mock) .mockResolvedValueOnce({ ok: true, json: async () => ({ user: mockUser }), }) .mockResolvedValueOnce({ ok: true, json: async () => ({ success: true }), }) const { result } = renderHook(() => useAuth(), { wrapper }) await waitFor(() => { expect(result.current.isLoading).toBe(false) }) await act(async () => { await result.current.signOut() }) expect(window.localStorage.getItem('auth-token')).toBeNull() })
it('throws error when useAuth is used outside of AuthProvider', () => { const consoleSpy = jest.spyOn(console, 'error').mockImplementation() expect(() => { renderHook(() => useAuth()) }).toThrow('useAuth must be used within an AuthProvider') consoleSpy.mockRestore() }) })