import { renderHook, act, waitFor }
from "@testing-library/react";
import { useInteractions }
from "../useInteractions";
import { useAuth }
from "@/contexts/AuthContext";
import type { ContentType }
from "@/types/supabase";
// Mock AuthContext jest.mock('@/contexts/AuthContext', () => ({ useAuth: jest.fn() })) // Mock fetch global.fetch = jest.fn() // Mock window.alert window.alert = jest.fn() const mockUseAuth = useAuth as jest.Mock const mockFetch = fetch as jest.Mock // Helper to create fetch response const createResponse = (data: any, ok = true) => ({ ok, json: async () => data })
describe('useInteractions', () => { const mockUser = { id: 'user-123', email: 'test@example.com' }

beforeEach(() => { jest.clearAllMocks() mockUseAuth.mockReturnValue({ user: mockUser }) })
afterEach(() => { jest.resetAllMocks() })
it('initializes with default values', async () => { mockFetch.mockResolvedValueOnce(createResponse({ count: 5, isLiked: true })) mockFetch.mockResolvedValueOnce(createResponse({ count: 3, isBookmarked: false }))

const { result } = renderHook(() => useInteractions('post-1', 'post' as ContentType) ) // Initial loading state expect(result.current.isLoading).toBe(true) expect(result.current.likes).toBe(0) expect(result.current.bookmarks).toBe(0) // Wait for fetch to complete await waitFor(() => { expect(result.current.isLoading).toBe(false) }) expect(result.current.likes).toBe(5) expect(result.current.isLiked).toBe(true) expect(result.current.bookmarks).toBe(3) expect(result.current.isBookmarked).toBe(false) })
it('uses initial values from options', async () => { mockFetch.mockResolvedValueOnce(createResponse({ count: 5, isLiked: true })) mockFetch.mockResolvedValueOnce(createResponse({ count: 3, isBookmarked: false }))

const { result } = renderHook(() => useInteractions('post-1', 'post' as ContentType, { initialLikes: 10, initialBookmarks: 20 }) ) // Should use initial values expect(result.current.likes).toBe(10) expect(result.current.bookmarks).toBe(20) // Wait for fetch to complete await waitFor(() => { expect(result.current.isLoading).toBe(false) }) // Should update with fetched values expect(result.current.likes).toBe(5) expect(result.current.bookmarks).toBe(3) })
it('fetches interactions with user ID when authenticated', async () => { mockFetch.mockResolvedValueOnce(createResponse({ count: 5, isLiked: true })) mockFetch.mockResolvedValueOnce(createResponse({ count: 3, isBookmarked: false })) renderHook(() => useInteractions('post-1', 'post' as ContentType) ) await waitFor(() => { expect(mockFetch).toHaveBeenCalledTimes(2) }) // Check likes API call expect(mockFetch).toHaveBeenCalledWith( expect.stringContaining('/api/likes?contentId=post-1&contentType=post&userId=user-123') ) // Check bookmarks API call expect(mockFetch).toHaveBeenCalledWith( expect.stringContaining('/api/bookmarks?contentId=post-1&contentType=post&userId=user-123') ) })
it('fetches interactions without user ID when not authenticated', async () => { mockUseAuth.mockReturnValue({ user: null }) mockFetch.mockResolvedValueOnce(createResponse({ count: 5, isLiked: false })) mockFetch.mockResolvedValueOnce(createResponse({ count: 3, isBookmarked: false })) renderHook(() => useInteractions('post-1', 'post' as ContentType) ) await waitFor(() => { expect(mockFetch).toHaveBeenCalledTimes(2) }) // Check API calls don't include userId expect(mockFetch).toHaveBeenCalledWith( expect.stringContaining('/api/likes?contentId=post-1&contentType=post') ) expect(mockFetch).not.toHaveBeenCalledWith( expect.stringContaining('userId=') ) })
it('handles fetch errors gracefully', async () => { const consoleError = jest.spyOn(console, 'error').mockImplementation() mockFetch.mockRejectedValueOnce(new Error('Network error')) mockFetch.mockRejectedValueOnce(new Error('Network error')) const { result } = renderHook(() => useInteractions('post-1', 'post' as ContentType) ) await waitFor(() => { expect(result.current.isLoading).toBe(false) }) expect(consoleError).toHaveBeenCalledWith('获取交互状态失败:', expect.any(Error)) expect(result.current.likes).toBe(0) expect(result.current.bookmarks).toBe(0) consoleError.mockRestore() })
it('toggles like when authenticated', async () => { mockFetch.mockResolvedValueOnce(createResponse({ count: 5, isLiked: false })) mockFetch.mockResolvedValueOnce(createResponse({ count: 3, isBookmarked: false }))

const { result } = renderHook(() => useInteractions('post-1', 'post' as ContentType) ) await waitFor(() => { expect(result.current.isLoading).toBe(false) }) // Mock like API response mockFetch.mockResolvedValueOnce(createResponse({ count: 6 })) await act(async () => { await result.current.toggleLike() }) expect(result.current.isLiked).toBe(true) expect(result.current.likes).toBe(6) expect(mockFetch).toHaveBeenCalledWith('/api/likes', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ contentId: 'post-1', contentType: 'post' }) }) })
it('removes like when already liked', async () => { mockFetch.mockResolvedValueOnce(createResponse({ count: 5, isLiked: true })) mockFetch.mockResolvedValueOnce(createResponse({ count: 3, isBookmarked: false }))

const { result } = renderHook(() => useInteractions('post-1', 'post' as ContentType) ) await waitFor(() => { expect(result.current.isLoading).toBe(false) }) // Mock unlike API response // First call returns undefined (from the first fetch with body: undefined) mockFetch.mockResolvedValueOnce(createResponse({})) // Second call is the actual DELETE mockFetch.mockResolvedValueOnce(createResponse({ count: 4 })) await act(async () => { await result.current.toggleLike() }) expect(result.current.isLiked).toBe(false) expect(result.current.likes).toBe(4) expect(mockFetch).toHaveBeenCalledWith( expect.stringContaining('/api/likes?contentId=post-1&contentType=post'), { method: 'DELETE' } ) })
it('shows alert when trying to like without authentication', async () => { mockUseAuth.mockReturnValue({ user: null }) mockFetch.mockResolvedValueOnce(createResponse({ count: 5, isLiked: false })) mockFetch.mockResolvedValueOnce(createResponse({ count: 3, isBookmarked: false }))

const { result } = renderHook(() => useInteractions('post-1', 'post' as ContentType) ) await waitFor(() => { expect(result.current.isLoading).toBe(false) }) await act(async () => { await result.current.toggleLike() }) expect(window.alert).toHaveBeenCalledWith('请先登录后再点赞') expect(result.current.isLiked).toBe(false) expect(result.current.likes).toBe(5) })
it('handles like toggle error with rollback', async () => { const consoleError = jest.spyOn(console, 'error').mockImplementation() mockFetch.mockResolvedValueOnce(createResponse({ count: 5, isLiked: false })) mockFetch.mockResolvedValueOnce(createResponse({ count: 3, isBookmarked: false }))

const { result } = renderHook(() => useInteractions('post-1', 'post' as ContentType) ) await waitFor(() => { expect(result.current.isLoading).toBe(false) }) // Mock failed like API response mockFetch.mockResolvedValueOnce(createResponse({}, false)) await act(async () => { await result.current.toggleLike() }) // Should rollback to original state expect(result.current.isLiked).toBe(false) expect(result.current.likes).toBe(5) expect(consoleError).toHaveBeenCalledWith('点赞操作失败:', expect.any(Error)) consoleError.mockRestore() })
it('toggles bookmark when authenticated', async () => { mockFetch.mockResolvedValueOnce(createResponse({ count: 5, isLiked: false })) mockFetch.mockResolvedValueOnce(createResponse({ count: 3, isBookmarked: false }))

const { result } = renderHook(() => useInteractions('post-1', 'post' as ContentType) ) await waitFor(() => { expect(result.current.isLoading).toBe(false) }) // Mock bookmark API response mockFetch.mockResolvedValueOnce(createResponse({ count: 4 })) await act(async () => { await result.current.toggleBookmark() }) expect(result.current.isBookmarked).toBe(true) expect(result.current.bookmarks).toBe(4) expect(mockFetch).toHaveBeenCalledWith('/api/bookmarks', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ contentId: 'post-1', contentType: 'post' }) }) })
it('removes bookmark when already bookmarked', async () => { mockFetch.mockResolvedValueOnce(createResponse({ count: 5, isLiked: false })) mockFetch.mockResolvedValueOnce(createResponse({ count: 3, isBookmarked: true }))

const { result } = renderHook(() => useInteractions('post-1', 'post' as ContentType) ) await waitFor(() => { expect(result.current.isLoading).toBe(false) }) // Mock unbookmark API response // First call returns undefined (from the first fetch with body: undefined) mockFetch.mockResolvedValueOnce(createResponse({})) // Second call is the actual DELETE mockFetch.mockResolvedValueOnce(createResponse({ count: 2 })) await act(async () => { await result.current.toggleBookmark() }) expect(result.current.isBookmarked).toBe(false) expect(result.current.bookmarks).toBe(2) expect(mockFetch).toHaveBeenCalledWith( expect.stringContaining('/api/bookmarks?contentId=post-1&contentType=post'), { method: 'DELETE' } ) })
it('shows alert when trying to bookmark without authentication', async () => { mockUseAuth.mockReturnValue({ user: null }) mockFetch.mockResolvedValueOnce(createResponse({ count: 5, isLiked: false })) mockFetch.mockResolvedValueOnce(createResponse({ count: 3, isBookmarked: false }))

const { result } = renderHook(() => useInteractions('post-1', 'post' as ContentType) ) await waitFor(() => { expect(result.current.isLoading).toBe(false) }) await act(async () => { await result.current.toggleBookmark() }) expect(window.alert).toHaveBeenCalledWith('请先登录后再收藏') expect(result.current.isBookmarked).toBe(false) expect(result.current.bookmarks).toBe(3) })
it('handles bookmark toggle error with rollback', async () => { const consoleError = jest.spyOn(console, 'error').mockImplementation() mockFetch.mockResolvedValueOnce(createResponse({ count: 5, isLiked: false })) mockFetch.mockResolvedValueOnce(createResponse({ count: 3, isBookmarked: false }))

const { result } = renderHook(() => useInteractions('post-1', 'post' as ContentType) ) await waitFor(() => { expect(result.current.isLoading).toBe(false) }) // Mock failed bookmark API response mockFetch.mockResolvedValueOnce(createResponse({}, false)) await act(async () => { await result.current.toggleBookmark() }) // Should rollback to original state expect(result.current.isBookmarked).toBe(false) expect(result.current.bookmarks).toBe(3) expect(consoleError).toHaveBeenCalledWith('收藏操作失败:', expect.any(Error)) consoleError.mockRestore() })
it('refetches interactions when called', async () => { mockFetch.mockResolvedValueOnce(createResponse({ count: 5, isLiked: false })) mockFetch.mockResolvedValueOnce(createResponse({ count: 3, isBookmarked: false }))

const { result } = renderHook(() => useInteractions('post-1', 'post' as ContentType) ) await waitFor(() => { expect(result.current.isLoading).toBe(false) }) expect(mockFetch).toHaveBeenCalledTimes(2) // Mock new values for refetch mockFetch.mockResolvedValueOnce(createResponse({ count: 10, isLiked: true })) mockFetch.mockResolvedValueOnce(createResponse({ count: 8, isBookmarked: true })) await act(async () => { await result.current.refetchInteractions() }) expect(mockFetch).toHaveBeenCalledTimes(4) expect(result.current.likes).toBe(10) expect(result.current.isLiked).toBe(true) expect(result.current.bookmarks).toBe(8) expect(result.current.isBookmarked).toBe(true) })
it('refetches when user changes', async () => { mockFetch.mockResolvedValueOnce(createResponse({ count: 5, isLiked: false })) mockFetch.mockResolvedValueOnce(createResponse({ count: 3, isBookmarked: false }))

const { result, rerender } = renderHook(() => useInteractions('post-1', 'post' as ContentType) ) await waitFor(() => { expect(result.current.isLoading).toBe(false) }) expect(mockFetch).toHaveBeenCalledTimes(2) // Change user const newUser = { id: 'user-456', email: 'new@example.com' }
mockUseAuth.mockReturnValue({ user: newUser }) // Mock new values for new user mockFetch.mockResolvedValueOnce(createResponse({ count: 7, isLiked: true })) mockFetch.mockResolvedValueOnce(createResponse({ count: 4, isBookmarked: true })) rerender() await waitFor(() => { expect(mockFetch).toHaveBeenCalledTimes(4) }) expect(result.current.likes).toBe(7) expect(result.current.isLiked).toBe(true) expect(result.current.bookmarks).toBe(4) expect(result.current.isBookmarked).toBe(true) }) })
